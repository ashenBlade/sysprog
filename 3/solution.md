# Решение

## Общее описание

Файловая система поддерживает 2 списка:
- Список файлов
- Список дескрипторов

Причем, все файлы организованы в единый список, а список дескрипторов представляет собой массив - для эффективной работы с дескрипторами.

## Структуры

### Файл

Структура файла - [`ufile_t`](./userfs.c).

Файл представляется набором своих блоков данных.
Каждый блок - это участок памяти, который занимает `BLOCK_SIZE`. 

В файле может быть 2 типа блоков:

1. Полностью заполненный
2. Частично заполненный

Первый тип (полностью заполненный) имеет размер (записанные данные) равный его вместимости. 
Все такие блоки идут в начале списка. 

Второй тип (частично заполненный) имеет размер меньше своей вместимости. 
При дозаписи используется именно он.

Таким образом, новый блок создается только если текущий полностью заполнен.

### Дескриптор

Структура дескриптора - [`ufd_t`](./userfs.c)

Дескриптор - это просто пара из указателя на файл и текущей позиции этого дескриптора.

## Основные операции с файлом

### Открытие

При открытии файла указываются название файла и его флаги.

Помимо стандартного `UFS_CREATE` используются и флаги для проверки операций.
Эти флаги хранятся в дескрипторе и проверяются перед каждой операцией.

Для обнаружения удаленных файлов, каждый файл хранит в себе поле `deleted`. 
При открытии, такие файлы отбрасываются.

### Чтение

Чтение из файла реализовано следующим образом.

Все блоки файла разделяются на 2 типа (в зависимости от начала чтения внутри блока): 

1. Со смещения - блок необходимо начать читать с какого-то смещения
2. С начала - блок необходимо прочитать полностью

Первый тип - это первый блок, который необходимо прочитать. Если позиция дескриптора указывает куда-то в середину блока.

Второй тип - это все остальные блоки цепочки (переход по указателю на следующий блок).

Это можно представить так:

```text
Блоки: |  1  |  2  |  3  |  4  |  5  |  6  |  7  |
                           |---------------------                      
```

На первой строке показаны блоки файла. На другой - какой диапазон необходимо считать.

Блок 4 читается частично, все остальные - полностью.

### Запись

Запись по тому же принципу. 

Все блоки разделяются на 2 типа (в зависимости от начала записи):

1. Со смещения - писать в блок необходимо начиная с определенного смещения
2. С начала - писать в блок необходимо с самого начала

Здесь есть 2 детали, которые стоит учитывать:

1. Список блоков может быть пустым (`NULL`) - ленивая инициализация
2. Позиция начала записи может находиться в конце файла и начинаться на границе блоков
3. Выделение новых блоков

Во всех случаях необходимо создать новый блок. 

Первые 2 случая, обнаруживаются (и исправляются) в самом начале одной проверкой - позиция дескриптора равна размеру файла и размер файла кратен размеру блока.

> Для оптимизации, кратность проверяется с помощью битовой маски, т.к. `512` - это `0x1000000000`

В последнем случае, в процессе записи, когда очередной блок закончился, необходимо просто создать новый блок.

### Закрытие дескриптора

Закрытие дескриптора реализовано просто: количество ссылок на файл уменьшается и объект дескриптора удаляется.

Также, при закрытии проверяется не удален ли исходный файл (флаг `deleted`). 
Если да, то удаляется и сам файл.

> Вместо хранения объектов дескрипторов, я удаляю их и высвобождаю место (`free`).
> Хоть структура и не занимает много места, но копейка рубль бережет.

### Удаление файла

При удалении файла необходимо учитывать то, что на него все еще могут ссылаться.

Если на момент вызова функции для удаления файла, на него еще ссылаются, то выставляется флаг `deleted`. 
Когда последний дескриптор будет закрываться, то файл удалится (выше про это написал).
То есть - это логическое удаление.

### Изменение размера файла

При изменении размера могут быть 2 случая:

1. Целевой размер *меньше* текущего
2. Целевой размер *больше* текущего

Если целевой размер больше, то имеет место следующая идея:

- Какое-то количество блоков будет полностью заполнено
- Последний блок необходимо заполнить частично

Стоит заметить, что последний блок может оказаться и текущим последним блоком.
В реализации это учитывается следующим образом:

1. Заводится переменная, хранящая последний блок. Она инициализируется текущим последним блоком
2. Рассчитывается количество блоков, которые должны быть полностью заполнены. 
   По факту, это разница между кол-вом блоков при новом размере и текущим количеством.
3. В цикле, каждый блок заполняется до своего предела (`BLOCK_SIZE`) и создается новый последний блок
4. После цикла, последний блок заполняется оставшимся размером

Можно заметить, что если новые блоки добавлять не нужно, то цикл на 3 шаге пустой и на шаге 4 просто увеличивается размер текущего последнего блока.
А если блоки есть, то сначала заполнится текущий последний блок и после начнут создаваться новые.

Если размер необходимо уменьшить, то алгоритм следующий:

1. Находится новый последний блок
2. Размер этого блока выставляется равным тому, что был бы при переданном размере
3. Все последующие блоки (переходы по указателю `next`) удаляются

## Детали

### Получение блока по смещению

Блоки файла хранятся в виде списка, а не массива. 
Для более эффективного поиска необходимого блока сравнивается расстояние до этого блока с начала и с конца.

Индекс нужного блока мы можем получить просто поделив смещение на сам размер блока. 
А количество блоков файла - поделив размер файла на размер блока.

Итерирование начинается с той стороны, до которой меньше идти.

### Проверка прав

Перед выполнением каждой операции производится проверка прав дескриптора: чтение/запись.

Я изменил перечисление и теперь `enum open_flags` представляет собой битовую маску:

- Чтение = `0x010`
- Запись = `0x100`

Таким образом, доступ на чтение и запись представляется в виде `0x110` и можно просто проверить доступ с помощью `&` вместо 2 операций сравнения.

