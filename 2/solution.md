# Решение

## Общее описание

Командная строка поддерживает всю необходимую функциональность:

- Исполнение команды с аргументами - `cmd arg1 arg2`
- Реализация встроенных команд - `cd`, `exit`
- Пайплайны  - `|`
- Перенаправление вывода в файл - `>`, `>>`
- Условное выполнение - `&&`, `||`
- Фоновая работа  -`&`

Для парсинга ввода использовал `parser.c`.

## Представление комаПредставление в коде

Структура команды представлена в [`include/command.h`](./include/command.h).

Введенная пользователем строка имеет следующий вид

```text
<first_pipeline> [ (<cond> <pipeline[i]>) ... ] [ (> | >> <filename>)] [ & ]
```

`first_pipeline` и `pipeline[i]` - представление пайплайна. 
Пайплайн - это 1 или несколько команд, объединенных пайпом.
Т.е. `cmd`, `cmd1 | cmd2 arg1 arg2` - это пайплайны.

`(<cond> <pipeline[i])` - это пара из пайплайна и условия его запуска. 
Условие (`cond`) - это либо `&&`, либо `||`. 
Этих пар может быть несколько, но главное то, что каждый пайплайн запускается только при выполнении этого условия.

> Стоит заметить, что `first_pipeline` - выполняется без условия и должен присутствовать в любом вводе всегда.
> Это также проявлено в коде - поле для структуры первого пайплайна вынесено отдельно.

`(> | >> <filename>)` - перенаправление вывода в файл. 

> Замечание - я смотрел примеры, требования и реализацию парсера (`struct command_line`) и пришел к выводу, что перенаправление вывода необходимо делать только для последнего пайплайна во всей команде - для других его нет. 
> Поэтому я реализовал такое же поведение - перенаправление вывода делается только для последнего пайплайна. Если он выполняться не будет, то и перенаправления соответственно не будет.

`&` - запуск в фоновом режиме

## Исполнение команды

Для исполнения команды используется `fork()`. 
Реализация логики выполнения содержится в функции `exec_exe_child` - она выполняется уже в процессе потомке. 
После `fork` вызывается `execvp` и запускается необходимая команда.

Для ожидания выполнения потомка используется `waitpid`.

Сама команда представляется структурой `exe`

```c
/** Представление запускаемого приложения - приложение и его аргументы */
typedef struct exe {
  /** Введенное название программы */
  const char *name;
  /** Аргументы, переданные этой программе */
  const char **args;
  /** Количество этих аргументов */
  int args_count;
} exe_t;
```

## Встроенные команды

Встроенные команды реализуются в файле [`builtin_command.c`](./builtin_command.c).

```c
struct builtin_command
{
	/** Название встроенной команды */
	const char* name;
	/** Функция для ее выполнения с переданными аргументами */
	int (*exec)(int argc, const char** argv);
};
```

Реализация проста: встроенная команда - это пара из названия команды (простая строка) и C функции (вход - аргументы, выход - код результата).

Все команды хранятся в статическом массиве.

Перед выполнением очередной команды (`execvp`) производится поиск встроенной команды внутри нашего массива. 
Если она найдена, то выполняется.


## Пайплайны

Пайплайн представляется структурой `pipeline_t`. 

```c
typedef struct pipeline {
  /** Последняя программа в этом пайплайне */
  exe_t last;
  /**
   * Дополнительные программы, которые должны быть запущены.
   * Если программа одна, то массив пуст (NULL)
   */
  exe_t *piped;
  /** Количество спайпленных команд, т.е. размер массива piped */
  int piped_count;
} pipeline_t;
```

Есть 2 замечания:

1. Пайплайн должен содержать как минимум 1 команду
2. Последняя команда в пайплайне должна обрабатываться "особенно":
   1. Встроенные команды должны влиять на сам терминал
   2. Результат их работы перенаправляется в `stdout`

Поэтому отдельно вынесено поле для последней команды.

Для перенаправления ввода/вывода подпрограмм используется `pipe` и `dup2`

> Замечание: в процессе словил баг неправильного перенаправления (мои кривые руки) из-за которого вывод последней команды перенаправлялся в `stdin`.
> В результате, следующей выполнявшейся командой были не введенные мной строки, а результат выполнения последнего пайплайна

Для выполнения пайплайна выделена отдельная функция `exec_pipeline`

## Перенаправление вывода в файл

Перенаправление вывода в файл реализуется костыльно: функция `exec_pipeline` не принимает дескриптор для `stdout`, а вместо этого вызывающая функция:

1. Вызывает `dup` для `stdout`
2. Открывает файл в нужном режиме
3. Вызывается `dup2(file_fd, STDOUT_FILENO)` (подмена STDOUT на файл)
4. Запускается пайплайн
5. `stdout` восстанавливается из сохраненного на 1 шаге дескриптора

## Условное выполнение

Сама команда представляется последовательностью нескольких пайплайнов, причем:

1. Первый пайплайн выполняется всегда
2. Остальные - в зависимости от условия запуска и кода предыдущего пайплайна

В коде, это реализовано так:

1. Поле для структуры первого пайплайна вынесено отдельно
2. Для остальных пайплайнов создана отдельная структура - пара из условия запуска и самого пайплайна

Выполнение следующее:

1. Запускается первый пайплайн и получается его код возврата (результат операции)
2. Находится следующий пайплайн, который удовлетворяет условию запуска 
    - Если найден, то выполняется и результат выполнения сохраняется
    - Если пайплайн последний, то дополнительно выполняется перенаправление вывода


Таблица условий запуска пайплайна: 

- По вертикали - код возврата предыдущего пайплайна
- По горизонтали - условие пайплайна

|     |     &&      | \|\| |
|-----|-------------|------|
| ==0 |      +      |  -   |
| !=0 |      -      |  +   |

## Фоновая работа

Фоновая работа по сути проста - выносим предыдущий код в отдельную функцию и запускаем через `fork()`. 
Но возникает проблема - зомби процессы. Нам необходимо ожидать завершения потомков.

Первое решение: игнорировать SIGCHLD - тогда зомби не будут создаваться. 
Проблема: нельзя вызывать `waitpid` для получения результата. Поэтому такое решение не годится.


Я решил эту проблему так: при завершении потомка отправляется `SIGUSR1` родительскому процессу, который вызывает `waitpid`.
Для того, чтобы получить pid отправившего процесса использую `sigaction` с флагом `SA_SIGINFO`.

Другая проблема - как потомок сможет *гарантировано* отправить этот сигнал? 
Например, если последней командой будет `exit`, то потомок просто завершится без сигнала.
Эту проблему решил через регистрацию обработчика - `atexit`, который этот сигнал и посылает.