# Решение

## Общее описание

Программа для внешней сортировки нескольких файлов с числами. 
Числа в файлах представлены в ASCII. 

На вход программе подается список из текстовых файлов, которые необходимо отсортировать. 
В результате создается файл `result.txt`, в котором находятся все отсортированные числа.

В процессе работы в директории `/tmp` создаются временные файлы. 
В конце работы они будут удалены.

## Реализация сортировки

Внешняя сортировка реализуется следующим образом:

1. Каждый файл сортируется с помощью сортировки вставками:
   - Каждое очередное число из файла считывается и кладется в отсортированный список ([`insertion_sort.c`](./insertion_sort.c))
   - Для определения места используется бинарный поиск
2. После сортировки всего файла, весь массив отсортированных чисел сохраняется во временный файл
   - Ничего не сериализуется - сохраняется полностью готовое представление как в памяти ([`utils.c`](./utils.c))
3. После сортировки всех отдельных файлов начинается этап слияния:
   - Для нахождения очередного наименьшего числа используется приоритетная очередь ([`priority_queue.c`](./priority_queue.c)) - ключ = очередное число из отсортированного массива

## Работа с файлами

Вся работа ведется с помощью числовых файловых дескрипторов и системных функций `read()`, `write()`, `lseek()`, `open()`, `close()`.

Также для чтения и записи реализуется собственная буферизация - чтение и запись производятся чанками по размеру страницы.
Для получения размера используется `sysconf(_SC_PAGESIZE)`.

Чтение чисел из исходных файлов - [`number_file_reader.c`](./number_file_reader.c):
- Чтение страницами
- При чтении учитывается то, что число может попадать на границу страницы, т.е. обрезаться. В таких случах, страница подгружается

Запись во временные файлы - буферизация не используется:
- После полной сортировки имеем непрерывный участок памяти, который сразу же и записываем (кастуем `int*` к `char*` и в цикле вызываем `write`)

Чтение из отсортированных файлов - [`page_reader` из `merge_files.c`](./merge_files.c):
- Чтение производится страницами
- При каждом чтении производится проверка, что прочитанное число байт кратно 4 (размер `int`) - если нет, то выполняется дополнительная итерация

Запись в результирующий файл - [`page_file_writer_state` из `merge_files.c`](./merge_files.c):
- Запись производится постранично
- При записи учитывается, то что число может быть обрезано границей страницы - тогда в буфер записывается столько, что заполнить оставшееся место, буфер сбрасывается и в буфер записываются оставшиеся байты числа

## Рассчет времени работы корутины

Для получения текущего времени используется `clock_gettime(CLOCK_MONOTONIC, ...)`.
В файле [`timespec_helpers.c`](./timespec_helpers.c) реализованы вспомогательные функции для работы со структурой `struct timespec`.

Подсчет времени работы реализован следующим образом:
- Каждая корутина хранит в себе поля:
  - `struct timespec total_work_time` - общее время работы корутины (без учета простоя)
  - `struct timespec start_time` - время запуска корутины
  - `bool is_running` - запущена ли корутина в данный момент
- Когда происходит смена контекста то поле `total_work_time` обновляется - записывается разница между текущим временем и записанным в `start_time`
- Общее время работы подсчитывается следующим образом:
  - Корутина либо не работает и остановлена - `total_work_time`
  - Либо сейчас работает - `total_work_time + (now - start_time)`

## Ограничение по времени

Задача:

> каждая из N корутин получает T / N микросекунд, где T - target latency введенное как параметр командной строки. После каждой итерации сортировки вы делаете yield только если квант времени текущей корутины закончился.

В аргументах командной строки в начале можно передать значение `latency` - `-l`/`--latency`.
После рассчитывается квант времени каждой корутины (переданное число делится на количество корутин). По умолчанию, это значение равно `100000` мкс (`100`мс).

Ограничение по времени реализуется следующим образом:
- Корутина хранит в себе поле `struct timespec quantum` - квант времени текущей корутины (константа)
- При инициализации корутин в `coro_sched` (глобальная корутина) сохраняется рассчитанный квант времени, который дальше сохраняется в каждую корутину (само значение передается в вызове `coro_init(struct timespec *quantum)` - изменил сигнатуру)
- При вызове `coro_yield()` подсчитывается время выполнения текущей корутины и если оно меньше кванта, то переключения контекста не происходит
- Для отслеживания подобных ситуаций каждая корутина хранит в себе поле `false_switch_count` - количесто "ложных" смен контекста (вызван `coro_yield()` но смены не произошло)

P.S. квант можно было бы хранить в глобальной переменной, но они запрещены

## Пол корутин

Задача:

> позволить задавать количество корутин. Каждая корутина должна работать вот так: если есть еще не отсортированные файлы, то взять один, отсортировать, повторить. Если все файлы отсортированы, то корутина завершается. Например, предположим, что есть 10 файлов и 3 корутины. Они берут по одному файлу, осталось еще 7. Одна корутина закончила свой файл, взяла следующий файл (6 файлов осталось). Еще одна корутина закончила другой файл и взяла следующий (5 файлов осталось). И так далее, пока все файлы не отсортированы. Затем вы делаете обычную сортировку слиянием. Этот бонус по сути предлагает вам реализовать пул (pool) корутин

При запуске приложения, ключом `-c`/`--coro-count` можно передать количество корутин, которое будет использоваться для сортировки файлов.

При запуске создается стек ([`stack_t` из `stack.c`](./stack.c)), который заполняется файлами для сортировки. 
После каждая корутина читает очередной файл из этого стека и выполняет его сортировку.

Замечание: реализация стека - не конкурентная, так как код хоть и асинхронный, но однопоточный и с кооперативной многозадачностью, поэтому одновременного доступа к стеку нескольких потоков не будет и операция чтения не прервется в момент вызова.

Сама функция корутины - это по факту `while(stack is not empty) { get_file(); sort_file_coro(); }` - изменения в коде минимальны.

## Сборка

Для сборки используется CMake. Дополнительно в процессе сборки можно указать определить ():

- `NO_CORO` - если указан, то все вызовы `coro_yield()` будут заменены `(void)0` - это для тестирования. По умолчанию выключен, т.е. `coro_yield()` будет вызываться
- `LEAK_CHECK` - добавить при сборке `utils/heap_check.c` для проверки утечек памяти. По умолчанию включен.

Запуск CMake (примерный):

```bash
mkdir build
cd build
cmake ..
```

## Тестирование

Для тестирования написал скрипт [`run-test.sh`](./run-test.sh):

- Собирает программу в папке `build` с помощью CMake
- Создает директорию `test`, в которой будут сгенерированные файлы с числами (не сортированные)
- Запускает программу и передает все файлы из `test`
- После работы запускает `cheker.py` по файлу `result.txt` (с отсортированными числами)
- Удаляет все сгенерированные файлы - `test/*`, `result.txt`

На вход ему подается количество файлов, которые нужно сгенерировать. 
В каждом файле будет `300000` чисел. 
Максимальное значение - максимальное для `int`.

Вызов:

```shell
./run-test.sh 10  # Запускает тест с 10 файлами
```

Вот мой вывод:

```text
Запускаю сборку приложения
Захожу в директорию build
-- The C compiler identification is GNU 11.4.0
-- The CXX compiler identification is GNU 11.4.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/user/sysprog/1/build
Запускаю make
[  9%] Building C object CMakeFiles/coroutines.dir/external_sort.c.o
[ 18%] Building C object CMakeFiles/coroutines.dir/libcoro.c.o
[ 27%] Building C object CMakeFiles/coroutines.dir/solution.c.o
[ 36%] Building C object CMakeFiles/coroutines.dir/utils.c.o
[ 45%] Building C object CMakeFiles/coroutines.dir/priority_queue.c.o
[ 54%] Building C object CMakeFiles/coroutines.dir/merge_files.c.o
[ 63%] Building C object CMakeFiles/coroutines.dir/number_file_reader.c.o
[ 72%] Building C object CMakeFiles/coroutines.dir/insertion_sort.c.o
[ 81%] Building C object CMakeFiles/coroutines.dir/timespec_helpers.c.o
[ 90%] Building C object CMakeFiles/coroutines.dir/stack.c.o
[100%] Linking C executable coroutines
[100%] Built target coroutines
Выхожу из директории build
Создаю директорию test
Создаю файл test/numbers1.txt
Создаю файл test/numbers2.txt
Создаю файл test/numbers3.txt
Создаю файл test/numbers4.txt
Запускаю приложение для тестирования
Рассчитанная задержка корутин: 0 с, 25000000 нс
Количество корутин: 4
Корутина завершилась:
        Время работы: 1 с, 300259781 нс
        Переключений контекста: 52
        Ложных переключений контекста: 299950
Корутина завершилась:
        Время работы: 1 с, 300258787 нс
        Переключений контекста: 52
        Ложных переключений контекста: 299950
Корутина завершилась:
        Время работы: 1 с, 300200672 нс
        Переключений контекста: 52
        Ложных переключений контекста: 299950
Корутина завершилась:
        Время работы: 1 с, 300242395 нс
        Переключений контекста: 52
        Ложных переключений контекста: 299950
Общее время работы: 5 с, 404841086 нс
Запускаю проверку корректности работы
All is ok
Проверка завершилась успешно
Удаляю сгенерированные файлы
```
